const vmt_LS
 :LS.Start
 :LS.Print
 :LS.Search
 :LS.Init


func Main()
 t.0 = HeapAllocZ(12)
 [t.0] = :vmt_LS
 if t.0 goto :null0
  Error("null pointer")
 null0:
 t.1 = [t.0]
 t.1 = [t.1+0]
 t.2 = call t.1(t.0 10)
 PrintIntS(t.2)
 ret 

func LS.Start(this sz)
 if this goto :null1
  Error("null pointer")
 null1:
 t.0 = [this]
 t.0 = [t.0+12]
 t.1 = call t.0(this sz)
 aux01 = t.1
 if this goto :null2
  Error("null pointer")
 null2:
 t.2 = [this]
 t.2 = [t.2+4]
 t.3 = call t.2(this)
 aux02 = t.3
 PrintIntS(9999)
 if this goto :null3
  Error("null pointer")
 null3:
 t.4 = [this]
 t.4 = [t.4+8]
 t.5 = call t.4(this 8)
 PrintIntS(t.5)
 if this goto :null4
  Error("null pointer")
 null4:
 t.6 = [this]
 t.6 = [t.6+8]
 t.7 = call t.6(this 12)
 PrintIntS(t.7)
 if this goto :null5
  Error("null pointer")
 null5:
 t.8 = [this]
 t.8 = [t.8+8]
 t.9 = call t.8(this 17)
 PrintIntS(t.9)
 if this goto :null6
  Error("null pointer")
 null6:
 t.10 = [this]
 t.10 = [t.10+8]
 t.11 = call t.10(this 50)
 PrintIntS(t.11)
 ret 55

func LS.Print(this)
 j = 1
 while0_top:
 t.0 = [this+8]
 t.1 = LtS(j t.0)
 if0 t.1 goto :while0_end
  t.2 = [this+4]
  s = [t.2]
  ok = Lt(j s)
  if ok goto :Label1
  Error("array index out of bounds")
  Label1: o =  MulS(j 4)
  d = Add(t.2 o)
  t.3 = [d+4]
  PrintIntS(t.3)
  t.4 = Add(j 1)
  j = t.4
  goto :while0_top
 while0_end:
 ret 0

func LS.Search(this num)
 j = 1
 ls01 = 0
 ifound = 0
 while1_top:
 t.0 = [this+8]
 t.1 = LtS(j t.0)
 if0 t.1 goto :while1_end
  t.2 = [this+4]
  s = [t.2]
  ok = Lt(j s)
  if ok goto :Label2
  Error("array index out of bounds")
  Label2: o =  MulS(j 4)
  d = Add(t.2 o)
  t.3 = [d+4]
  aux01 = t.3
  t.4 = Add(num 1)
  aux02 = t.4
  t.5 = LtS(aux01 num)
  if0 t.5 goto :if0_else
   nt = 0
   goto :if0_end
  if0_else:
   t.6 = LtS(aux01 aux02)
   t.7 = Sub(1 t.6)
   if0 t.7 goto :if1_else
    nt = 0
    goto :if1_end
   if1_else:
    ls01 = 1
    ifound = 1
    j = [this+8]
   if1_end:
  if0_end:
  t.8 = Add(j 1)
  j = t.8
  goto :while1_top
 while1_end:
 ret ifound

func LS.Init(this sz)
 [this+8] = sz
 t.0 = call :AllocArray(sz)
 [this+4] = t.0
 j = 1
 t.1 = [this+8]
 t.2 = Add(t.1 1)
 k = t.2
 while2_top:
 t.3 = [this+8]
 t.4 = LtS(j t.3)
 if0 t.4 goto :while2_end
  t.5 = MulS(2 j)
  aux01 = t.5
  t.6 = Sub(k 3)
  aux02 = t.6
  t.7 = [this+4]
  s = [t.7]
  ok = LtS(j s)
  if ok goto :Label3
  Error("array index out of bounds")
  Label3: ok = LtS(-1 j)
  if ok goto :Label4
  Error("array index out of bounds")
  Label4: o =  MulS(j 4)
  t.8 = [this+4]
  t.9 = Add(t.8 o)
  t.10 = Add(aux01 aux02)
  [t.9+4] = t.10
  t.11 = Add(j 1)
  j = t.11
  t.12 = Sub(k 1)
  k = t.12
  goto :while2_top
 while2_end:
 ret 0

func AllocArray(size)
 bytes = MulS(size 4)
 bytes = Add(bytes 4)
 v = HeapAllocZ(bytes)
 [v] = size
 ret v
